#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { autoGenerateDocs } from "./auto-generate-docs.mjs";

/**
 * Valida que todos los exports documentados en el glosario est√©n implementados
 * y que no haya exports no documentados.
 * Si encuentra exports sin documentar, los genera autom√°ticamente.
 */

async function validateExports() {
  console.log("üîç Validating exports against GLOSARIO_MAESTRO.md...");

  try {
    // Leer el glosario maestro
    const glosarioPath = "docs/GLOSARIO_MAESTRO.md";
    const glosario = fs.readFileSync(glosarioPath, "utf8");

    // Extraer exports esperados del glosario
    const expectedExports = extractExpectedExports(glosario);

    // Lista de tipos cr√≠ticos que requieren ADR si cambian
    const CRITICAL_TYPES = [
      'PatientId', 'DoctorId', 'CompanyId', 'UUID',
      'Patient', 'Doctor', 'Appointment', 'MedicalRecord',
      'APIResponse', 'AuthUser', 'UserRole',
      'ISODateString', 'EmailAddress', 'PhoneNumber'
    ];

    // Validar cada package
    const packages = ["types", "shared", "auth", "hooks"];
    let hasErrors = false;
    let hasCriticalChanges = false;

    for (const pkg of packages) {
      const packagePath = `packages/${pkg}/src/index.ts`;

      if (!fs.existsSync(packagePath)) {
        console.error(`‚ùå Package index not found: ${packagePath}`);
        hasErrors = true;
        continue;
      }

      const indexContent = fs.readFileSync(packagePath, "utf8");
      const actualExports = extractActualExports(indexContent);
      const expected = expectedExports[`@autamedica/${pkg}`] || [];

      // Verificar exports faltantes
      const missing = expected.filter(exp => !actualExports.includes(exp));
      if (missing.length > 0) {
        console.error(`‚ùå @autamedica/${pkg} missing exports:`, missing.join(", "));
        hasErrors = true;
      }

      // Verificar exports no documentados
      const undocumented = actualExports.filter(exp => !expected.includes(exp));
      if (undocumented.length > 0) {
        console.warn(`‚ö†Ô∏è  @autamedica/${pkg} undocumented exports:`, undocumented.join(", "));

        // Verificar si hay tipos cr√≠ticos no documentados
        const criticalUndocumented = undocumented.filter(exp => CRITICAL_TYPES.includes(exp));
        if (criticalUndocumented.length > 0) {
          console.error(`üö® CRITICAL: Undocumented critical types: ${criticalUndocumented.join(", ")}`);
          console.error(`   These require documentation in GLOSARIO_MAESTRO.md and ADR if breaking change`);
          hasErrors = true;
          hasCriticalChanges = true;
        } else {
          // Para exports no cr√≠ticos, marcar para auto-generaci√≥n
          hasErrors = true; // Esto activar√° la auto-generaci√≥n
        }
      }

      // Verificar cambios en tipos cr√≠ticos (para packages types)
      if (pkg === 'types') {
        const criticalExports = actualExports.filter(exp => CRITICAL_TYPES.includes(exp));
        if (criticalExports.length > 0) {
          console.log(`üîí Critical types found: ${criticalExports.join(", ")}`);

          // Si es CI, verificar si hay ADR para cambios cr√≠ticos
          if (process.env.CI && hasCriticalChanges) {
            const adrPath = 'docs/adr';
            if (!fs.existsSync(adrPath)) {
              console.error(`üö® CRITICAL: No ADR directory found at ${adrPath}`);
              console.error(`   Critical type changes require Architecture Decision Records`);
              hasErrors = true;
            } else {
              console.log(`üìã ADR directory exists - ensure critical changes are documented`);
            }
          }
        }
      }

      if (!hasErrors) {
        console.log(`‚úÖ @autamedica/${pkg} exports are valid`);
      }
    }

    if (hasErrors) {
      console.log("\nüîß Intentando generar documentaci√≥n autom√°tica...");

      try {
        await autoGenerateDocs();
        console.log("\n‚ú® Documentaci√≥n generada. Ejecutando validaci√≥n nuevamente...");

        // Re-ejecutar validaci√≥n despu√©s de generar docs
        await validateExportsSecondPass();
      } catch (autoGenError) {
        console.error(`‚ùå Error en auto-generaci√≥n: ${autoGenError.message}`);
        console.error("\n‚ùå Export validation failed!");
        process.exit(1);
      }
    } else {
      console.log("\nüéâ All exports are properly documented and implemented!");
    }

  } catch (error) {
    console.error("‚ùå Validation script failed:", error.message);
    process.exit(1);
  }
}

function normalizeExportName(name) {
  return name
    .trim()
    .replace(/\s+as\s+.+$/iu, "")
    .replace(/\/\*.*?\*\//gu, "")
    .replace(/[\s;]+/g, "")
    .replace(/,$/, "")
    .trim();
}

function collectExportsFromCode(code, exportsSet) {
  const namedExportRegex = /export(?:\s+type)?\s*\{([^}]+)\}/g;
  let namedMatch;
  while ((namedMatch = namedExportRegex.exec(code)) !== null) {
    const names = namedMatch[1]
      .split(",")
      .map(normalizeExportName)
      .filter(Boolean);

    for (const name of names) {
      exportsSet.add(name);
    }
  }

  const singleExportRegexes = [
    /export\s+const\s+([A-Za-z0-9_]+)/g,
    /export\s+function\s+([A-Za-z0-9_]+)/g,
    /export\s+class\s+([A-Za-z0-9_]+)/g,
    /export\s+enum\s+([A-Za-z0-9_]+)/g,
    /export\s+interface\s+([A-Za-z0-9_]+)/g,
    /export\s+type\s+([A-Za-z0-9_]+)/g,
  ];

  for (const regex of singleExportRegexes) {
    let singleMatch;
    while ((singleMatch = regex.exec(code)) !== null) {
      const name = normalizeExportName(singleMatch[1]);
      if (name) {
        exportsSet.add(name);
      }
    }
  }
}

function extractExpectedExports(glosarioContent) {
  const expected = {};

  // Priorizar la secci√≥n autogenerada si existe
  const autoSectionMatch = glosarioContent.match(/<!-- AUTOGEN_PACKAGES:START -->([\s\S]*?)<!-- AUTOGEN_PACKAGES:END -->/);
  if (autoSectionMatch) {
    const autoContent = autoSectionMatch[1];
    const lineRegex = /-\s+([a-zA-Z0-9_-]+):\s*([^\n]*)/g;
    let lineMatch;
    while ((lineMatch = lineRegex.exec(autoContent)) !== null) {
      const pkgSlug = lineMatch[1].trim();
      const symbolsLine = lineMatch[2] ?? "";
      const symbols = Array.from(symbolsLine.matchAll(/`([^`]+)`/g))
        .map((match) => match[1].trim())
        .filter(Boolean);
      if (symbols.length > 0) {
        expected[`@autamedica/${pkgSlug}`] = symbols;
      }
    }
  }

  const addCodeBlocksToPackage = (content, packageName) => {
    if (!content) {
      return;
    }

    const exportsSet = new Set(expected[packageName] ?? []);
    const codeBlockRegex = /```typescript([\s\S]*?)```/g;
    let codeMatch;
    while ((codeMatch = codeBlockRegex.exec(content)) !== null) {
      collectExportsFromCode(codeMatch[1], exportsSet);
    }

    if (exportsSet.size > 0) {
      expected[packageName] = [...exportsSet];
    }
  };

  // Bloques generales (antes de la secci√≥n por package) pertenecen a @autamedica/types
  const [generalContent, packagesContent = ""] = glosarioContent.split("## üìñ Exports por Package");
  if (!expected['@autamedica/types']) {
    addCodeBlocksToPackage(generalContent, "@autamedica/types");
  }

  // Capturar el contenido de cada secci√≥n de package del glosario
  const sectionRegex = /### @autamedica\/([^\n]+)\n([\s\S]*?)(?=### @autamedica\/|$)/g;

  let sectionMatch;
  while ((sectionMatch = sectionRegex.exec(packagesContent)) !== null) {
    const packageName = sectionMatch[1].trim();
    const sectionContent = sectionMatch[2] ?? "";

    if (!expected[`@autamedica/${packageName}`]) {
      addCodeBlocksToPackage(sectionContent, `@autamedica/${packageName}`);
    }
  }

  return expected;
}

function extractActualExports(indexContent) {
  const exportsSet = new Set();
  collectExportsFromCode(indexContent, exportsSet);
  return [...exportsSet];
}

/**
 * Segunda pasada de validaci√≥n despu√©s de auto-generar documentaci√≥n
 */
async function validateExportsSecondPass() {
  console.log("üîÑ Segunda validaci√≥n despu√©s de auto-generaci√≥n...");

  try {
    // Leer el glosario actualizado
    const glosarioPath = "docs/GLOSARIO_MAESTRO.md";
    const glosario = fs.readFileSync(glosarioPath, "utf8");
    const expectedExports = extractExpectedExports(glosario);

    const packages = ["types", "shared", "auth", "hooks"];
    let stillHasErrors = false;

    for (const pkg of packages) {
      const packagePath = `packages/${pkg}/src/index.ts`;

      if (!fs.existsSync(packagePath)) {
        continue;
      }

      const indexContent = fs.readFileSync(packagePath, "utf8");
      const actualExports = extractActualExports(indexContent);
      const expected = expectedExports[`@autamedica/${pkg}`] || [];

      const undocumented = actualExports.filter(exp => !expected.includes(exp));
      if (undocumented.length > 0) {
        console.error(`‚ùå @autamedica/${pkg} a√∫n tiene exports sin documentar:`, undocumented.join(", "));
        stillHasErrors = true;
      }
    }

    if (stillHasErrors) {
      console.error("\n‚ùå Algunos exports siguen sin documentar despu√©s de auto-generaci√≥n!");
      console.error("üîß Revisa el archivo docs/GLOSARIO_MAESTRO.md manualmente");
      process.exit(1);
    } else {
      console.log("\nüéâ ¬°Todos los exports est√°n documentados despu√©s de auto-generaci√≥n!");
    }

  } catch (error) {
    console.error("‚ùå Segunda validaci√≥n fall√≥:", error.message);
    process.exit(1);
  }
}

validateExports();
