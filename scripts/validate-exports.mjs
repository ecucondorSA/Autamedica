#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { autoGenerateDocs } from "./auto-generate-docs.mjs";

/**
 * Valida que todos los exports documentados en el glosario estén implementados
 * y que no haya exports no documentados.
 * Si encuentra exports sin documentar, los genera automáticamente.
 */

// Lista de exports internos permitidos (NO requieren documentación)
// Exportada a nivel de módulo para reutilización en múltiples funciones
const ALLOWED_INTERNAL_EXPORTS = [
  // Utility types genéricos
  'Brand', 'Id', 'NonEmptyString', 'PositiveNumber', 'Percentage',
  'JsonPrimitive', 'JsonValue', 'JsonObject', 'JsonArray',
  'Nullable', 'Optional', 'Maybe', 'NonNullable', 'ReadonlyDeep', 'MutableDeep',
  'NonEmptyArray', 'ArrayElement', 'KeysOf', 'ValuesOf', 'NonEmptyObject',
  'VoidFunction', 'ThrowsFunction', 'AsyncFunction', 'Callback', 'Predicate',
  'DiscriminateUnion', 'MapDiscriminatedUnion',

  // IDs secundarios y especializados
  'PrescriptionId', 'MedicalHistoryId', 'OrganizationId', 'EmployeeId', 'TenantId', 'UserId',
  'SpecialtyId', 'ReproductiveHealthSpecialistId', 'CommunityGroupId', 'GroupMembershipId',
  'PostId', 'CommentId', 'ReactionId', 'ReportId', 'CommunityNotificationId',
  'PreventiveScreeningId', 'MedicalCaseId', 'ScreeningReminderNotificationId',

  // Supabase auto-generated schemas (snake_case variants)
  'AppointmentSnakeSchema', 'AppointmentInsertSnakeSchema', 'AppointmentUpdateSnakeSchema',
  'PatientProfileSnakeSchema', 'PatientInsertSnakeSchema', 'PatientUpdateSnakeSchema',
  'CompanyMemberSnakeSchema', 'CompanyMemberInsertSnakeSchema', 'CompanyMemberUpdateSnakeSchema',

  // Profile DTOs (Insert/Update variants)
  'Profile', 'ProfileInsert', 'ProfileUpdate',
  'DoctorProfile', 'DoctorInsert', 'DoctorWithProfile', 'DoctorUpdate',
  'PatientProfile', 'PatientInsert', 'PatientWithProfile', 'PatientUpdate',
  'CompanyProfile', 'CompanyInsert', 'CompanyUpdate', 'CompanyWithMembers',
  'MedicalCertification', 'WeeklySchedule', 'DaySchedule',
  'MedicalCondition', 'Allergy', 'Medication', 'InsuranceInfo', 'Gender',

  // Type parsers y validators auto-generados
  'parseAppointmentForUI', 'safeParseAppointmentForUI', 'parsePatientsForUI', 'parseAppointmentsForUI',
  'parsePatientForUI', 'safeParsePatientForUI', 'parseCompanyMemberForUI',
  'safeParseCompanyMemberForUI', 'parseCompanyMembersForUI',
  'isValidAppointmentForDisplay', 'isDurationConsistent',
  'isPatientProfileComplete', 'isMinor', 'requiresGuardianConsent',
  'hasValidEmergencyContact', 'getBMICategory', 'hasInsurance',
  'getYearsOfService', 'isOnProbation', 'canApprovExpenses', 'hasAccessToSensitiveData',
  'isProfile', 'isValidRole', 'isProfileComplete', 'isPatient', 'isDoctor',
  'isDoctorEducation', 'isAppointment', 'isAppointmentType', 'isAppointmentStatus',

  // Type helpers snake_case
  'typeAppointmentSnake', 'typeAppointmentInsertSnake', 'typeAppointmentUpdateSnake',
  'typePatientSnake', 'typePatientInsertSnake', 'typePatientUpdateSnake',
  'typeCompanyMemberSnake', 'typeCompanyMemberInsertSnake', 'typeCompanyMemberUpdateSnake',

  // Base entity types (infrastructure)
  'BaseEntity', 'CreateEntityInput', 'UpdateEntityInput', 'EntityFilters',
  'PaginatedResponse', 'PaginationParams',
  'isEntityDeleted', 'isEntityActive', 'markEntityAsDeleted',

  // API Response types (infrastructure)
  'ApiErrorCode', 'ApiError', 'ApiResponse', 'MedicalApiResponse', 'MedicalAudit', 'ComplianceInfo',

  // Loading states (infrastructure)
  'LoadingState', 'DataLoadingState', 'Loadable', 'AsyncState', 'MedicalLoadable', 'AuthenticatedLoadable',
  'isUnauthenticated', 'mapLoadable', 'flatMapLoadable', 'combineLoadables',
  'getLoadableValue', 'unwrapLoadable',

  // Geographic types (internal)
  'CountryCode', 'StateCode', 'ZipCode', 'Coordinates', 'Address',

  // Communication types (internal)
  'PhoneE164', 'NationalPhone', 'PHONE_VALIDATION_CONFIG',

  // Medical specialty types (internal catalogs)
  'SpecialtyCode', 'MedicalLicenseNumber', 'SubspecialtyCode', 'CertificationId',
  'MedicalSpecialty', 'MedicalSubspecialty', 'MedicalLicense', 'LicenseProvinceCode',
  'TimeHHmm', 'TimeSlot', 'ProfessionalInsurance', 'ARS',

  // Doctor internal types
  'DoctorPublicProfile', 'DoctorPrivateData', 'DoctorLookupResult',
  'DoctorAPIResponse', 'DoctorPublicAPIResponse', 'DoctorListAPIResponse',
  'isValidEmail', 'isValidURL',

  // Patient internal types
  'DNI', 'ICD10Code', 'MedicalRecordNumber', 'InsurancePolicyNumber',
  'HeightCm', 'WeightKg', 'BMI', 'BloodType', 'AllergySeverity', 'VitalSigns', 'InsurancePlan',
  'PatientPublicProfile', 'PatientMedicalView', 'PatientAdminView', 'PatientPrivateData',
  'PatientAPIResponse', 'PatientMedicalAPIResponse', 'PatientListAPIResponse',

  // Rating/Review system (feature-specific)
  'RatingScore', 'PatientCount', 'ReviewId', 'Percent0to100',
  'PatientReview', 'PatientVolumeMetrics', 'AutamedicaRecognition',
  'DoctorPublicRating', 'DoctorRatingDisplay', 'DoctorRatingAPIResponse',
  'ReviewSubmissionResult', 'RecognitionAPIResponse', 'ReviewListAPIResponse',

  // Patient care team (feature-specific)
  'PatientCareTeam', 'PatientCareTeamRole', 'PatientCareTeamInsert',
  'PatientCareTeamUpdate', 'PatientCareTeamWithDetails', 'isPatientCareTeamRole', 'isPrimaryDoctor',

  // Appointment types (feature-specific)
  'AppointmentType', 'AppointmentStatus', 'AppointmentInsert', 'AppointmentUpdate',
  'AppointmentWithDetails', 'APPOINTMENT_TYPES', 'APPOINTMENT_STATUSES',
  'isTerminalStatus', 'requiresMeetingUrl', 'requiresPhysicalLocation',

  // Audit system (feature-specific)
  'AuditLog', 'AuditAction', 'AuditResourceType', 'AuditLogInsert',
  'MedicalActionMetadata', 'AuthActionMetadata', 'DataExportMetadata',
  'AuditLogFilters', 'AuditLogPage', 'AUDIT_ACTIONS', 'AUDIT_RESOURCE_TYPES',
  'isAuditLog', 'isAuditAction', 'isAuditResourceType', 'isCriticalAction',
  'containsPHI', 'formatAuditDescription',

  // Company members (feature-specific)
  'CompanyMember', 'CompanyMemberRole', 'CompanyMemberInsert', 'CompanyMemberUpdate',
  'CompanyDepartment', 'CompanyMemberWithDetails', 'CompanyMemberFilters', 'CompanyMemberStats',
  'COMPANY_MEMBER_ROLES', 'COMPANY_DEPARTMENTS', 'isCompanyMemberRole', 'isCompanyDepartment',
  'hasAdminPermissions', 'canManageMembers', 'isActiveMember', 'getEmploymentDuration',
  'getDepartmentDisplayName',

  // Reproductive health (specialized feature)
  'SpecialistAvailabilityStatus', 'ReproductiveHealthSpecialtyType',
  'ReproductiveHealthSpecialist', 'ReproductiveHealthSpecialistWithProfile', 'ReproductiveHealthSpecialistInsert',
  'ReproductiveHealthAppointmentId', 'AppointmentConsultationType', 'AppointmentModalityType', 'AppointmentStatusType',
  'ReproductiveHealthAppointment', 'ReproductiveHealthAppointmentInsert', 'ReproductiveHealthAppointmentUpdate',
  'ReproductiveHealthAppointmentWithDetails', 'HealthCenterId', 'HealthCenterType', 'HealthCenter',
  'OperatingHours', 'TimeRange', 'HealthCenterInsert', 'HealthCenterWithDistance',
  'MedicalChatId', 'MedicalMessageId', 'MessageAuthorType', 'MessageContentType', 'ChatStatusType',
  'MedicalChat', 'MedicalMessage', 'MedicalChatInsert', 'MedicalMessageInsert', 'MedicalChatWithLastMessage',
  'GeolocationQuery', 'HealthCenterSearchFilters', 'ReproductiveHealthStats',
  'SpecialistAvailability', 'AvailableSlot',
  'isReproductiveHealthSpecialty', 'isAppointmentConsultationType', 'isHealthCenterType',
  'isSpecialistAvailable', 'canAcceptEmergency', 'isChatActive', 'requiresUrgentAttention',
  'calculateDistance', 'sortByDistance', 'formatDistance', 'estimateTravelTime',
  'getSpecialtyDisplayName', 'getConsultationTypeDisplayName',

  // Anamnesis (specialized feature)
  'AnamnesisId', 'AnamnesisSection', 'AnamnesisStatus', 'AnamnesisSectionStatus',
  'Anamnesis', 'AnamnesisInsert', 'AnamnesisUpdate',
  'PersonalDataSection', 'EmergencyContactSection',
  'MedicalHistoryItem', 'FamilyHistoryItem', 'AllergyItem', 'CurrentMedicationItem',
  'ChronicConditionItem', 'SurgicalHistoryItem', 'HospitalizationItem',
  'GynecologicalHistorySection', 'LifestyleSection', 'MentalHealthSection', 'ConsentSection',
  'AnamnesisSectionData', 'AnamnesisAPIResponse', 'AnamnesisProgressResponse',
  'SECTION_ORDER', 'SECTION_DISPLAY_NAMES',
  'isAnamnesisComplete', 'calculateSectionWeight', 'getNextPendingSection',
  'canEditAnamnesis', 'requiresDoctorReview',

  // Telemedicine (specialized feature)
  'TelemedicineSessionId', 'WebRTCPeerId', 'SignalingRoomId',
  'SessionStatus', 'ConnectionQuality', 'ParticipantRole',
  'TelemedicineSession', 'TelemedicineSessionMetadata',
  'DeviceInfo', 'NetworkStats', 'VideoQualitySettings', 'AudioQualitySettings',
  'SignalingMessage', 'SignalingMessageType', 'SignalingPayload',
  'JoinPayload', 'LeavePayload', 'OfferPayload', 'AnswerPayload', 'ICECandidatePayload', 'RenegotiatePayload',
  'MediaCapabilities', 'SessionParticipant', 'MediaState', 'RTCPeerConnectionState',
  'SessionEvent', 'SessionEventType',
  'TelemedicineQuickAction', 'QuickActionType', 'QuickActionData',
  'WaitingRoomEntry', 'PreCallChecklist',
  'TelemedicineSessionAPIResponse', 'StartSessionRequest', 'StartSessionResponse',
  'TURNServerConfig', 'ICEServerConfig',
  'isSessionActive', 'canJoinSession', 'getConnectionQualityScore',
  'calculateSessionDuration', 'requiresRecordingConsent', 'getQualityRecommendation',
  'CommunityGroup',

  // Community features (specialized feature)
  'GroupCategory', 'GroupRule', 'CommunityGroupInsert', 'GroupMembership',
  'MemberRole', 'MembershipStatus', 'GroupMembershipInsert',
  'CommunityPost', 'ModerationStatus', 'CommunityPostInsert', 'CommunityPostUpdate',
  'PostComment', 'PostCommentInsert', 'PostCommentUpdate',
  'PostReaction', 'ReactionType', 'PostReactionInsert',
  'ContentReport', 'ReportReason', 'ReportStatus', 'ModerationAction', 'ContentReportInsert',
  'CommunityNotification', 'CommunityNotificationType',
  'UserReputation', 'ReputationBadge', 'CommunityFeedFilters', 'TrendingTopic',
  'CommunityPostAPIResponse', 'CommunityFeedAPIResponse', 'CommunityGroupAPIResponse',
  'GROUP_CATEGORIES_DISPLAY', 'REACTION_DISPLAY',
  'canModerateContent', 'isContentApproved', 'requiresModerationReview',
  'calculateReputationScore', 'canPostInGroup', 'anonymizeDisplayName', 'isHighRiskContent',

  // Preventive screening (specialized feature)
  'GenderType', 'ScreeningCategoryType', 'ScreeningFrequencyType', 'RiskLevelType', 'ScreeningStatusType',
  'PreventiveScreening', 'PatientScreening', 'RiskFactor', 'PatientRiskFactor',
  'ScreeningReminderNotification', 'MedicalCase', 'MedicalCaseSection',
  'PreventiveScreeningInsert', 'PatientScreeningInsert', 'PatientRiskFactorInsert',
  'ScreeningReminderNotificationInsert', 'PatientScreeningWithDetails',
  'PreventiveScreeningWithStats', 'AgeRange', 'ScreeningRecommendation', 'ScreeningCatalogKey',
  'isScreeningApplicable', 'calculateNextDueDate', 'calculateUrgency', 'SCREENING_CATALOG',

  // Supabase Database types auto-generated
  'Database', 'Json', 'Tables', 'TablesInsert', 'TablesUpdate',
  'SupabaseApiResponse', 'SupabasePaginatedResponse',
  'isSupabaseApiResponse', 'isSupabaseError', 'isSupabaseSuccess', 'getSupabaseErrorMessage',

  // Internal config types
  'ID_VALIDATION_CONFIG', 'USER_ROLES', 'COMPANY_SIZES', 'GENDERS',

  // Case converters (internal utilities)
  'toCamel', 'toSnake', 'typeCamelCased', 'typeSnakeCased',

  // Session helpers (redundant with main session types)
  'typeSession', 'typeSessionRole',

  // Role helpers (redundant with UserRole)
  'roleToPortal', 'roleToPortalDev', 'getDefaultRedirectUrl',
  'hasAdminAccess', 'canManageOrganizations', 'canManageCompany',
  'canAccessMedicalFeatures', 'getRoleDisplayName', 'getRoleDescription',
  'isValidUserRole', 'requiresVerification', 'AVAILABLE_ROLES', 'VERIFIED_ROLES',

  // Auth helpers (covered by main auth types)
  'getAppUrl', 'getBaseUrlForRole', 'AppRole',
  'isCorrectAppForRole', 'getCorrectAppUrl', 'storeLastPath', 'getLastPath', 'clearLastPath',
  'getPortalUrlWithPath', 'isCorrectPortal', 'isAllowedRedirect', 'safeRedirectOrFallback', 'buildSafeLoginUrl',

  // Supabase client (internal implementation)
  'supabase', 'selectActive', 'selectActiveRaw', 'selectById',
  'insertRecord', 'updateRecord', 'softDelete', 'hardDelete', 'restoreRecord', 'countActive',
  'typeSelectOptions',

  // WebRTC internal (covered by main telemedicine types)
  'WebRTCDiagnostics', 'ICE_SERVERS',

  // Env helpers (redundant with main env functions)
  'getOptionalClientEnv', 'getClientEnvOrDefault', 'getServerEnvOrDefault',

  // Validation helpers
  'isValidEmail', 'isValidDNI', 'isValidTimeHHmm', 'isValidBloodType',
  'isValidDoctorEmail', 'isValidDoctorURL',

  // ID generation helpers
  'createId', 'validateIdForScope', 'createValidatedId', 'generateUUID',
  'generatePrefixedId', 'generatePatientId', 'generateDoctorId', 'generateAppointmentId',

  // Date/Time helpers
  'ISODateTime', 'isISODateString', 'toISODateString', 'nowAsISODateString',

  // Medical calculation helpers
  'calculateBMI', 'calculateAge', 'calculateRiskLevel', 'hasActiveAllergies',
  'isHighRiskPatient', 'requiresSpecializedCare', 'canReceiveTelemedicine',
  'generatePatientDisplayName', 'createPatientPublicProfile', 'createMedicalView',
  'extractPatientPrivateData', 'isPublicHealthcareEligible', 'isPAMIEligible',
  'hasInsuranceCoverage',

  // Doctor specialty helpers
  'MEDICAL_SPECIALTIES', 'SUBSPECIALTIES', 'CERTIFICATION_TYPES', 'LICENSE_STATUS',
  'isValidSpecialtyCode', 'isValidSubspecialtyCode', 'isValidMedicalLicense',
  'isActiveLicense', 'isValidCertification', 'getSpecialtiesRequiring',
  'getAvailableSubspecialties', 'getSpecialtiesByCategory', 'createBasicSpecialty',
  'formatMedicalLicense', 'extractProvinceFromLicense', 'createMedicalLicense',
  'canPracticeSpecialty', 'canPracticeInArgentina', 'isDoctorLicenseActive',
  'isDoctorProfileComplete', 'calculateTotalTrainingYears', 'calculateYearsOfExperience',
  'generateDisplayName', 'acceptsInsurancePlan', 'isAvailableOnDay',
  'createPublicProfile', 'extractPrivateData',

  // Review helpers
  'REVIEW_WINDOW_DAYS', 'isValidRatingScore', 'canSubmitReview',
  'calculatePatientReviewsScore', 'calculateReviewsBreakdown', 'calculateVolumeScore',
  'calculateRecognitionScore', 'calculateOverallRating', 'calculateMonthsActive',
  'calculateVolumePercentile', 'isEligibleForRecognition', 'createRatingDisplay',
  'getRecognitionBadgeText',

  // Insurance helpers
  'ARGENTINA_INSURANCE_PROVIDERS',

  // Medical record helpers (already documented in glossary)
  'MEDICAL_RECORD_VISIBILITIES', 'isMedicalRecordVisibility', 'canAccessRecord',
  'isHighSensitivityRecord', 'isPermanentRecord'
];

async function validateExports() {
  console.log("🔍 Validating exports against glossaries...");

  try {
    // Leer glosarios modulares
    const glossaryDir = "docs/glossary";
    let glosario = "";

    // Si existe el directorio de glosarios, leer todos los archivos .md
    if (fs.existsSync(glossaryDir)) {
      const glossaryFiles = fs.readdirSync(glossaryDir).filter(f => f.endsWith('.md'));
      for (const file of glossaryFiles) {
        const content = fs.readFileSync(path.join(glossaryDir, file), "utf8");
        glosario += content + "\n\n";
      }
      console.log(`📚 Loaded ${glossaryFiles.length} modular glossaries`);
    }

    // Fallback: leer glosario maestro si existe
    const glosarioPath = "docs/GLOSARIO_MAESTRO.md";
    if (fs.existsSync(glosarioPath)) {
      const masterGlosario = fs.readFileSync(glosarioPath, "utf8");
      glosario += masterGlosario;
      console.log("📚 Loaded GLOSARIO_MAESTRO.md");
    }

    if (!glosario) {
      console.warn("⚠️  No glossaries found, skipping validation");
      return;
    }

    // Extraer exports esperados del glosario
    const expectedExports = extractExpectedExports(glosario);

    // Lista de tipos críticos que requieren ADR si cambian
    const CRITICAL_TYPES = [
      'PatientId', 'DoctorId', 'CompanyId', 'UUID',
      'Patient', 'Doctor', 'Appointment', 'MedicalRecord',
      'APIResponse', 'AuthUser', 'UserRole',
      'ISODateString', 'EmailAddress', 'PhoneNumber'
    ];

    // Validar cada package
    const packages = ["types", "shared", "auth", "hooks"];
    let hasErrors = false;
    let hasCriticalChanges = false;

    for (const pkg of packages) {
      const packagePath = `packages/${pkg}/src/index.ts`;

      if (!fs.existsSync(packagePath)) {
        console.error(`❌ Package index not found: ${packagePath}`);
        hasErrors = true;
        continue;
      }

      const indexContent = fs.readFileSync(packagePath, "utf8");
      const actualExports = extractActualExports(indexContent);
      const expected = expectedExports[`@autamedica/${pkg}`] || [];

      // Verificar exports faltantes
      const missing = expected.filter(exp => !actualExports.includes(exp));
      if (missing.length > 0) {
        console.error(`❌ @autamedica/${pkg} missing exports:`, missing.join(", "));
        hasErrors = true;
      }

      // Verificar exports no documentados (excluyendo internos permitidos)
      const undocumented = actualExports
        .filter(exp => !expected.includes(exp))
        .filter(exp => !ALLOWED_INTERNAL_EXPORTS.includes(exp));

      if (undocumented.length > 0) {
        console.warn(`⚠️  @autamedica/${pkg} undocumented exports (${undocumented.length}):`, undocumented.join(", "));

        // Verificar si hay tipos críticos no documentados
        const criticalUndocumented = undocumented.filter(exp => CRITICAL_TYPES.includes(exp));
        if (criticalUndocumented.length > 0) {
          console.error(`🚨 CRITICAL: Undocumented critical types: ${criticalUndocumented.join(", ")}`);
          console.error(`   These require documentation in GLOSARIO_MAESTRO.md and ADR if breaking change`);
          hasErrors = true;
          hasCriticalChanges = true;
        } else {
          // Para exports no críticos, marcar para auto-generación
          hasErrors = true; // Esto activará la auto-generación
        }
      }

      // Verificar cambios en tipos críticos (para packages types)
      if (pkg === 'types') {
        const criticalExports = actualExports.filter(exp => CRITICAL_TYPES.includes(exp));
        if (criticalExports.length > 0) {
          console.log(`🔒 Critical types found: ${criticalExports.join(", ")}`);

          // Si es CI, verificar si hay ADR para cambios críticos
          if (process.env.CI && hasCriticalChanges) {
            const adrPath = 'docs/adr';
            if (!fs.existsSync(adrPath)) {
              console.error(`🚨 CRITICAL: No ADR directory found at ${adrPath}`);
              console.error(`   Critical type changes require Architecture Decision Records`);
              hasErrors = true;
            } else {
              console.log(`📋 ADR directory exists - ensure critical changes are documented`);
            }
          }
        }
      }

      if (!hasErrors) {
        console.log(`✅ @autamedica/${pkg} exports are valid`);
      }
    }

    if (hasErrors) {
      console.log("\n🔧 Intentando generar documentación automática...");

      try {
        await autoGenerateDocs();
        console.log("\n✨ Documentación generada. Ejecutando validación nuevamente...");

        // Re-ejecutar validación después de generar docs
        await validateExportsSecondPass();
      } catch (autoGenError) {
        console.error(`❌ Error en auto-generación: ${autoGenError.message}`);
        console.error("\n❌ Export validation failed!");
        process.exit(1);
      }
    } else {
      console.log("\n🎉 All exports are properly documented and implemented!");
    }

  } catch (error) {
    console.error("❌ Validation script failed:", error.message);
    process.exit(1);
  }
}

function normalizeExportName(name) {
  return name
    .trim()
    .replace(/\s+as\s+.+$/iu, "")
    .replace(/\/\*.*?\*\//gu, "")
    .replace(/[\s;]+/g, "")
    .replace(/,$/, "")
    .trim();
}

function collectExportsFromCode(code, exportsSet) {
  // Regex mejorado para capturar export { } multi-línea
  const namedExportRegex = /export(?:\s+type)?\s*\{([\s\S]*?)\}/g;
  let namedMatch;
  while ((namedMatch = namedExportRegex.exec(code)) !== null) {
    const names = namedMatch[1]
      .split(/[,\n]/)  // Split por comas Y newlines
      .map(normalizeExportName)
      .filter(Boolean);

    for (const name of names) {
      exportsSet.add(name);
    }
  }

  const singleExportRegexes = [
    /export\s+const\s+([A-Za-z0-9_]+)/g,
    /export\s+function\s+([A-Za-z0-9_]+)/g,
    /export\s+class\s+([A-Za-z0-9_]+)/g,
    /export\s+enum\s+([A-Za-z0-9_]+)/g,
    /export\s+interface\s+([A-Za-z0-9_]+)/g,
    /export\s+type\s+([A-Za-z0-9_]+)/g,
  ];

  for (const regex of singleExportRegexes) {
    let singleMatch;
    while ((singleMatch = regex.exec(code)) !== null) {
      const name = normalizeExportName(singleMatch[1]);
      if (name) {
        exportsSet.add(name);
      }
    }
  }
}

function extractExpectedExports(glosarioContent) {
  const expected = {};

  // Priorizar la sección autogenerada si existe
  const autoSectionMatch = glosarioContent.match(/<!-- AUTOGEN_PACKAGES:START -->([\s\S]*?)<!-- AUTOGEN_PACKAGES:END -->/);
  if (autoSectionMatch) {
    const autoContent = autoSectionMatch[1];
    const lineRegex = /-\s+([a-zA-Z0-9_-]+):\s*([^\n]*)/g;
    let lineMatch;
    while ((lineMatch = lineRegex.exec(autoContent)) !== null) {
      const pkgSlug = lineMatch[1].trim();
      const symbolsLine = lineMatch[2] ?? "";
      const symbols = Array.from(symbolsLine.matchAll(/`([^`]+)`/g))
        .map((match) => match[1].trim())
        .filter(Boolean);
      if (symbols.length > 0) {
        expected[`@autamedica/${pkgSlug}`] = symbols;
      }
    }
  }

  const addCodeBlocksToPackage = (content, packageName) => {
    if (!content) {
      return;
    }

    const exportsSet = new Set(expected[packageName] ?? []);
    const codeBlockRegex = /```typescript([\s\S]*?)```/g;
    let codeMatch;
    while ((codeMatch = codeBlockRegex.exec(content)) !== null) {
      collectExportsFromCode(codeMatch[1], exportsSet);
    }

    if (exportsSet.size > 0) {
      expected[packageName] = [...exportsSet];
    }
  };

  // Bloques generales (antes de la sección por package) pertenecen a @autamedica/types
  const [generalContent, packagesContent = ""] = glosarioContent.split("## 📖 Exports por Package");
  if (!expected['@autamedica/types']) {
    addCodeBlocksToPackage(generalContent, "@autamedica/types");
  }

  // Capturar el contenido de cada sección de package del glosario
  // Soporta tanto ### (3 hashes) como ## (2 hashes) para compatibilidad con glosarios modulares
  const sectionRegex = /##+ @autamedica\/([^\n]+)\n([\s\S]*?)(?=##+ @autamedica\/|##+ [A-Z]|$)/g;

  let sectionMatch;
  while ((sectionMatch = sectionRegex.exec(packagesContent)) !== null) {
    const packageName = sectionMatch[1].trim();
    const sectionContent = sectionMatch[2] ?? "";

    if (!expected[`@autamedica/${packageName}`]) {
      addCodeBlocksToPackage(sectionContent, `@autamedica/${packageName}`);
    }
  }

  // También procesar secciones de glosario completo (que incluye modulares)
  // Buscar secciones ## @autamedica/ en todo el contenido
  const fullSectionRegex = /## @autamedica\/([^\n]+)\n([\s\S]*?)(?=## @autamedica\/|## [🎯📚]|---\n\n##|$)/g;
  let fullMatch;
  while ((fullMatch = fullSectionRegex.exec(glosarioContent)) !== null) {
    const packageName = fullMatch[1].trim();
    const sectionContent = fullMatch[2] ?? "";

    if (!expected[`@autamedica/${packageName}`]) {
      addCodeBlocksToPackage(sectionContent, `@autamedica/${packageName}`);
    }
  }

  return expected;
}

function extractActualExports(indexContent) {
  const exportsSet = new Set();
  collectExportsFromCode(indexContent, exportsSet);
  return [...exportsSet];
}

/**
 * Segunda pasada de validación después de auto-generar documentación
 */
async function validateExportsSecondPass() {
  console.log("🔄 Segunda validación después de auto-generación...");

  try {
    // Leer glosarios modulares
    const glossaryDir = "docs/glossary";
    let glosario = "";

    if (fs.existsSync(glossaryDir)) {
      const glossaryFiles = fs.readdirSync(glossaryDir).filter(f => f.endsWith('.md'));
      for (const file of glossaryFiles) {
        const content = fs.readFileSync(path.join(glossaryDir, file), "utf8");
        glosario += content + "\n\n";
      }
    }

    // Fallback: leer glosario maestro
    const glosarioPath = "docs/GLOSARIO_MAESTRO.md";
    if (fs.existsSync(glosarioPath)) {
      const masterGlosario = fs.readFileSync(glosarioPath, "utf8");
      glosario += masterGlosario;
    }

    const expectedExports = extractExpectedExports(glosario);

    // Reutilizar la misma lista ALLOWED_INTERNAL_EXPORTS del módulo
    const packages = ["types", "shared", "auth", "hooks"];
    let stillHasErrors = false;

    for (const pkg of packages) {
      const packagePath = `packages/${pkg}/src/index.ts`;

      if (!fs.existsSync(packagePath)) {
        continue;
      }

      const indexContent = fs.readFileSync(packagePath, "utf8");
      const actualExports = extractActualExports(indexContent);
      const expected = expectedExports[`@autamedica/${pkg}`] || [];

      // Aplicar MISMO filtro que primera pasada
      const undocumented = actualExports
        .filter(exp => !expected.includes(exp))
        .filter(exp => !ALLOWED_INTERNAL_EXPORTS.includes(exp));

      if (undocumented.length > 0) {
        console.error(`❌ @autamedica/${pkg} aún tiene exports sin documentar (${undocumented.length}):`, undocumented.join(", "));
        stillHasErrors = true;
      } else {
        console.log(`✅ @autamedica/${pkg} exports válidos después de auto-generación`);
      }
    }

    if (stillHasErrors) {
      console.error("\n❌ Algunos exports siguen sin documentar después de auto-generación!");
      console.error("🔧 Revisa el archivo docs/GLOSARIO_MAESTRO.md manualmente");
      process.exit(1);
    } else {
      console.log("\n🎉 ¡Todos los exports están documentados después de auto-generación!");
    }

  } catch (error) {
    console.error("❌ Segunda validación falló:", error.message);
    process.exit(1);
  }
}

validateExports();
