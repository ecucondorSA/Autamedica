#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { autoGenerateDocs } from "./auto-generate-docs.mjs";

/**
 * Valida que todos los exports documentados en el glosario est√©n implementados
 * y que no haya exports no documentados.
 * Si encuentra exports sin documentar, los genera autom√°ticamente.
 */

// Lista de exports internos permitidos (NO requieren documentaci√≥n)
// Exportada a nivel de m√≥dulo para reutilizaci√≥n en m√∫ltiples funciones
const ALLOWED_INTERNAL_EXPORTS = [
  // Utility types gen√©ricos
  'Brand', 'Id', 'NonEmptyString', 'PositiveNumber', 'Percentage',
  'JsonPrimitive', 'JsonValue', 'JsonObject', 'JsonArray',
  'Nullable', 'Optional', 'Maybe', 'NonNullable', 'ReadonlyDeep', 'MutableDeep',
  'NonEmptyArray', 'ArrayElement', 'KeysOf', 'ValuesOf', 'NonEmptyObject',
  'VoidFunction', 'ThrowsFunction', 'AsyncFunction', 'Callback', 'Predicate',
  'DiscriminateUnion', 'MapDiscriminatedUnion',

  // IDs secundarios y especializados
  'PrescriptionId', 'MedicalHistoryId', 'OrganizationId', 'EmployeeId', 'TenantId', 'UserId',
  'SpecialtyId', 'ReproductiveHealthSpecialistId', 'CommunityGroupId', 'GroupMembershipId',
  'PostId', 'CommentId', 'ReactionId', 'ReportId', 'CommunityNotificationId',
  'PreventiveScreeningId', 'MedicalCaseId', 'ScreeningReminderNotificationId',

  // Supabase auto-generated schemas (snake_case variants)
  'AppointmentSnakeSchema', 'AppointmentInsertSnakeSchema', 'AppointmentUpdateSnakeSchema',
  'PatientProfileSnakeSchema', 'PatientInsertSnakeSchema', 'PatientUpdateSnakeSchema',
  'CompanyMemberSnakeSchema', 'CompanyMemberInsertSnakeSchema', 'CompanyMemberUpdateSnakeSchema',

  // Profile DTOs (Insert/Update variants)
  'Profile', 'ProfileInsert', 'ProfileUpdate',
  'DoctorProfile', 'DoctorInsert', 'DoctorWithProfile', 'DoctorUpdate',
  'PatientProfile', 'PatientInsert', 'PatientWithProfile', 'PatientUpdate',
  'CompanyProfile', 'CompanyInsert', 'CompanyUpdate', 'CompanyWithMembers',
  'MedicalCertification', 'WeeklySchedule', 'DaySchedule',
  'MedicalCondition', 'Allergy', 'Medication', 'InsuranceInfo', 'Gender',

  // Type parsers y validators auto-generados
  'parseAppointmentForUI', 'safeParseAppointmentForUI', 'parsePatientsForUI', 'parseAppointmentsForUI',
  'parsePatientForUI', 'safeParsePatientForUI', 'parseCompanyMemberForUI',
  'safeParseCompanyMemberForUI', 'parseCompanyMembersForUI',
  'isValidAppointmentForDisplay', 'isDurationConsistent',
  'isPatientProfileComplete', 'isMinor', 'requiresGuardianConsent',
  'hasValidEmergencyContact', 'getBMICategory', 'hasInsurance',
  'getYearsOfService', 'isOnProbation', 'canApprovExpenses', 'hasAccessToSensitiveData',
  'isProfile', 'isValidRole', 'isProfileComplete', 'isPatient', 'isDoctor',
  'isDoctorEducation', 'isAppointment', 'isAppointmentType', 'isAppointmentStatus',

  // Type helpers snake_case
  'typeAppointmentSnake', 'typeAppointmentInsertSnake', 'typeAppointmentUpdateSnake',
  'typePatientSnake', 'typePatientInsertSnake', 'typePatientUpdateSnake',
  'typeCompanyMemberSnake', 'typeCompanyMemberInsertSnake', 'typeCompanyMemberUpdateSnake',

  // Base entity types (infrastructure)
  'BaseEntity', 'CreateEntityInput', 'UpdateEntityInput', 'EntityFilters',
  'PaginatedResponse', 'PaginationParams',
  'isEntityDeleted', 'isEntityActive', 'markEntityAsDeleted',

  // API Response types (infrastructure)
  'ApiErrorCode', 'ApiError', 'ApiResponse', 'MedicalApiResponse', 'MedicalAudit', 'ComplianceInfo',

  // Loading states (infrastructure)
  'LoadingState', 'DataLoadingState', 'Loadable', 'AsyncState', 'MedicalLoadable', 'AuthenticatedLoadable',
  'isUnauthenticated', 'mapLoadable', 'flatMapLoadable', 'combineLoadables',
  'getLoadableValue', 'unwrapLoadable',

  // Geographic types (internal)
  'CountryCode', 'StateCode', 'ZipCode', 'Coordinates', 'Address',

  // Communication types (internal)
  'PhoneE164', 'NationalPhone', 'PHONE_VALIDATION_CONFIG',

  // Medical specialty types (internal catalogs)
  'SpecialtyCode', 'MedicalLicenseNumber', 'SubspecialtyCode', 'CertificationId',
  'MedicalSpecialty', 'MedicalSubspecialty', 'MedicalLicense', 'LicenseProvinceCode',
  'TimeHHmm', 'TimeSlot', 'ProfessionalInsurance', 'ARS',

  // Doctor internal types
  'DoctorPublicProfile', 'DoctorPrivateData', 'DoctorLookupResult',
  'DoctorAPIResponse', 'DoctorPublicAPIResponse', 'DoctorListAPIResponse',
  'isValidEmail', 'isValidURL',

  // Patient internal types
  'DNI', 'ICD10Code', 'MedicalRecordNumber', 'InsurancePolicyNumber',
  'HeightCm', 'WeightKg', 'BMI', 'BloodType', 'AllergySeverity', 'VitalSigns', 'InsurancePlan',
  'PatientPublicProfile', 'PatientMedicalView', 'PatientAdminView', 'PatientPrivateData',
  'PatientAPIResponse', 'PatientMedicalAPIResponse', 'PatientListAPIResponse',

  // Rating/Review system (feature-specific)
  'RatingScore', 'PatientCount', 'ReviewId', 'Percent0to100',
  'PatientReview', 'PatientVolumeMetrics', 'AutamedicaRecognition',
  'DoctorPublicRating', 'DoctorRatingDisplay', 'DoctorRatingAPIResponse',
  'ReviewSubmissionResult', 'RecognitionAPIResponse', 'ReviewListAPIResponse',

  // Patient care team (feature-specific)
  'PatientCareTeam', 'PatientCareTeamRole', 'PatientCareTeamInsert',
  'PatientCareTeamUpdate', 'PatientCareTeamWithDetails', 'isPatientCareTeamRole', 'isPrimaryDoctor',

  // Appointment types (feature-specific)
  'AppointmentType', 'AppointmentStatus', 'AppointmentInsert', 'AppointmentUpdate',
  'AppointmentWithDetails', 'APPOINTMENT_TYPES', 'APPOINTMENT_STATUSES',
  'isTerminalStatus', 'requiresMeetingUrl', 'requiresPhysicalLocation',

  // Audit system (feature-specific)
  'AuditLog', 'AuditAction', 'AuditResourceType', 'AuditLogInsert',
  'MedicalActionMetadata', 'AuthActionMetadata', 'DataExportMetadata',
  'AuditLogFilters', 'AuditLogPage', 'AUDIT_ACTIONS', 'AUDIT_RESOURCE_TYPES',
  'isAuditLog', 'isAuditAction', 'isAuditResourceType', 'isCriticalAction',
  'containsPHI', 'formatAuditDescription',

  // Company members (feature-specific)
  'CompanyMember', 'CompanyMemberRole', 'CompanyMemberInsert', 'CompanyMemberUpdate',
  'CompanyDepartment', 'CompanyMemberWithDetails', 'CompanyMemberFilters', 'CompanyMemberStats',
  'COMPANY_MEMBER_ROLES', 'COMPANY_DEPARTMENTS', 'isCompanyMemberRole', 'isCompanyDepartment',
  'hasAdminPermissions', 'canManageMembers', 'isActiveMember', 'getEmploymentDuration',
  'getDepartmentDisplayName',

  // Reproductive health (specialized feature)
  'SpecialistAvailabilityStatus', 'ReproductiveHealthSpecialtyType',
  'ReproductiveHealthSpecialist', 'ReproductiveHealthSpecialistWithProfile', 'ReproductiveHealthSpecialistInsert',
  'ReproductiveHealthAppointmentId', 'AppointmentConsultationType', 'AppointmentModalityType', 'AppointmentStatusType',
  'ReproductiveHealthAppointment', 'ReproductiveHealthAppointmentInsert', 'ReproductiveHealthAppointmentUpdate',
  'ReproductiveHealthAppointmentWithDetails', 'HealthCenterId', 'HealthCenterType', 'HealthCenter',
  'OperatingHours', 'TimeRange', 'HealthCenterInsert', 'HealthCenterWithDistance',
  'MedicalChatId', 'MedicalMessageId', 'MessageAuthorType', 'MessageContentType', 'ChatStatusType',
  'MedicalChat', 'MedicalMessage', 'MedicalChatInsert', 'MedicalMessageInsert', 'MedicalChatWithLastMessage',
  'GeolocationQuery', 'HealthCenterSearchFilters', 'ReproductiveHealthStats',
  'SpecialistAvailability', 'AvailableSlot',
  'isReproductiveHealthSpecialty', 'isAppointmentConsultationType', 'isHealthCenterType',
  'isSpecialistAvailable', 'canAcceptEmergency', 'isChatActive', 'requiresUrgentAttention',
  'calculateDistance', 'sortByDistance', 'formatDistance', 'estimateTravelTime',
  'getSpecialtyDisplayName', 'getConsultationTypeDisplayName',

  // Anamnesis (specialized feature)
  'AnamnesisId', 'AnamnesisSection', 'AnamnesisStatus', 'AnamnesisSectionStatus',
  'Anamnesis', 'AnamnesisInsert', 'AnamnesisUpdate',
  'PersonalDataSection', 'EmergencyContactSection',
  'MedicalHistoryItem', 'FamilyHistoryItem', 'AllergyItem', 'CurrentMedicationItem',
  'ChronicConditionItem', 'SurgicalHistoryItem', 'HospitalizationItem',
  'GynecologicalHistorySection', 'LifestyleSection', 'MentalHealthSection', 'ConsentSection',
  'AnamnesisSectionData', 'AnamnesisAPIResponse', 'AnamnesisProgressResponse',
  'SECTION_ORDER', 'SECTION_DISPLAY_NAMES',
  'isAnamnesisComplete', 'calculateSectionWeight', 'getNextPendingSection',
  'canEditAnamnesis', 'requiresDoctorReview',

  // Telemedicine (specialized feature)
  'TelemedicineSessionId', 'WebRTCPeerId', 'SignalingRoomId',
  'SessionStatus', 'ConnectionQuality', 'ParticipantRole',
  'TelemedicineSession', 'TelemedicineSessionMetadata',
  'DeviceInfo', 'NetworkStats', 'VideoQualitySettings', 'AudioQualitySettings',
  'SignalingMessage', 'SignalingMessageType', 'SignalingPayload',
  'JoinPayload', 'LeavePayload', 'OfferPayload', 'AnswerPayload', 'ICECandidatePayload', 'RenegotiatePayload',
  'MediaCapabilities', 'SessionParticipant', 'MediaState', 'RTCPeerConnectionState',
  'SessionEvent', 'SessionEventType',
  'TelemedicineQuickAction', 'QuickActionType', 'QuickActionData',
  'WaitingRoomEntry', 'PreCallChecklist',
  'TelemedicineSessionAPIResponse', 'StartSessionRequest', 'StartSessionResponse',
  'TURNServerConfig', 'ICEServerConfig',
  'isSessionActive', 'canJoinSession', 'getConnectionQualityScore',
  'calculateSessionDuration', 'requiresRecordingConsent', 'getQualityRecommendation',
  'CommunityGroup',

  // Community features (specialized feature)
  'GroupCategory', 'GroupRule', 'CommunityGroupInsert', 'GroupMembership',
  'MemberRole', 'MembershipStatus', 'GroupMembershipInsert',
  'CommunityPost', 'ModerationStatus', 'CommunityPostInsert', 'CommunityPostUpdate',
  'PostComment', 'PostCommentInsert', 'PostCommentUpdate',
  'PostReaction', 'ReactionType', 'PostReactionInsert',
  'ContentReport', 'ReportReason', 'ReportStatus', 'ModerationAction', 'ContentReportInsert',
  'CommunityNotification', 'CommunityNotificationType',
  'UserReputation', 'ReputationBadge', 'CommunityFeedFilters', 'TrendingTopic',
  'CommunityPostAPIResponse', 'CommunityFeedAPIResponse', 'CommunityGroupAPIResponse',
  'GROUP_CATEGORIES_DISPLAY', 'REACTION_DISPLAY',
  'canModerateContent', 'isContentApproved', 'requiresModerationReview',
  'calculateReputationScore', 'canPostInGroup', 'anonymizeDisplayName', 'isHighRiskContent',

  // Preventive screening (specialized feature)
  'GenderType', 'ScreeningCategoryType', 'ScreeningFrequencyType', 'RiskLevelType', 'ScreeningStatusType',
  'PreventiveScreening', 'PatientScreening', 'RiskFactor', 'PatientRiskFactor',
  'ScreeningReminderNotification', 'MedicalCase', 'MedicalCaseSection',
  'PreventiveScreeningInsert', 'PatientScreeningInsert', 'PatientRiskFactorInsert',
  'ScreeningReminderNotificationInsert', 'PatientScreeningWithDetails',
  'PreventiveScreeningWithStats', 'AgeRange', 'ScreeningRecommendation', 'ScreeningCatalogKey',
  'isScreeningApplicable', 'calculateNextDueDate', 'calculateUrgency', 'SCREENING_CATALOG',

  // Supabase Database types auto-generated
  'Database', 'Json', 'Tables', 'TablesInsert', 'TablesUpdate',
  'SupabaseApiResponse', 'SupabasePaginatedResponse',
  'isSupabaseApiResponse', 'isSupabaseError', 'isSupabaseSuccess', 'getSupabaseErrorMessage',

  // Internal config types
  'ID_VALIDATION_CONFIG', 'USER_ROLES', 'COMPANY_SIZES', 'GENDERS',

  // Case converters (internal utilities)
  'toCamel', 'toSnake', 'typeCamelCased', 'typeSnakeCased',

  // Session helpers (redundant with main session types)
  'typeSession', 'typeSessionRole',

  // Role helpers (redundant with UserRole)
  'roleToPortal', 'roleToPortalDev', 'getDefaultRedirectUrl',
  'hasAdminAccess', 'canManageOrganizations', 'canManageCompany',
  'canAccessMedicalFeatures', 'getRoleDisplayName', 'getRoleDescription',
  'isValidUserRole', 'requiresVerification', 'AVAILABLE_ROLES', 'VERIFIED_ROLES',

  // Auth helpers (covered by main auth types)
  'getAppUrl', 'getBaseUrlForRole', 'AppRole',
  'isCorrectAppForRole', 'getCorrectAppUrl', 'storeLastPath', 'getLastPath', 'clearLastPath',
  'getPortalUrlWithPath', 'isCorrectPortal', 'isAllowedRedirect', 'safeRedirectOrFallback', 'buildSafeLoginUrl',

  // Supabase client (internal implementation)
  'supabase', 'selectActive', 'selectActiveRaw', 'selectById',
  'insertRecord', 'updateRecord', 'softDelete', 'hardDelete', 'restoreRecord', 'countActive',
  'typeSelectOptions',

  // WebRTC internal (covered by main telemedicine types)
  'WebRTCDiagnostics', 'ICE_SERVERS',

  // Env helpers (redundant with main env functions)
  'getOptionalClientEnv', 'getClientEnvOrDefault', 'getServerEnvOrDefault',

  // Validation helpers
  'isValidEmail', 'isValidDNI', 'isValidTimeHHmm', 'isValidBloodType',
  'isValidDoctorEmail', 'isValidDoctorURL',

  // ID generation helpers
  'createId', 'validateIdForScope', 'createValidatedId', 'generateUUID',
  'generatePrefixedId', 'generatePatientId', 'generateDoctorId', 'generateAppointmentId',

  // Date/Time helpers
  'ISODateTime', 'isISODateString', 'toISODateString', 'nowAsISODateString',

  // Medical calculation helpers
  'calculateBMI', 'calculateAge', 'calculateRiskLevel', 'hasActiveAllergies',
  'isHighRiskPatient', 'requiresSpecializedCare', 'canReceiveTelemedicine',
  'generatePatientDisplayName', 'createPatientPublicProfile', 'createMedicalView',
  'extractPatientPrivateData', 'isPublicHealthcareEligible', 'isPAMIEligible',
  'hasInsuranceCoverage',

  // Doctor specialty helpers
  'MEDICAL_SPECIALTIES', 'SUBSPECIALTIES', 'CERTIFICATION_TYPES', 'LICENSE_STATUS',
  'isValidSpecialtyCode', 'isValidSubspecialtyCode', 'isValidMedicalLicense',
  'isActiveLicense', 'isValidCertification', 'getSpecialtiesRequiring',
  'getAvailableSubspecialties', 'getSpecialtiesByCategory', 'createBasicSpecialty',
  'formatMedicalLicense', 'extractProvinceFromLicense', 'createMedicalLicense',
  'canPracticeSpecialty', 'canPracticeInArgentina', 'isDoctorLicenseActive',
  'isDoctorProfileComplete', 'calculateTotalTrainingYears', 'calculateYearsOfExperience',
  'generateDisplayName', 'acceptsInsurancePlan', 'isAvailableOnDay',
  'createPublicProfile', 'extractPrivateData',

  // Review helpers
  'REVIEW_WINDOW_DAYS', 'isValidRatingScore', 'canSubmitReview',
  'calculatePatientReviewsScore', 'calculateReviewsBreakdown', 'calculateVolumeScore',
  'calculateRecognitionScore', 'calculateOverallRating', 'calculateMonthsActive',
  'calculateVolumePercentile', 'isEligibleForRecognition', 'createRatingDisplay',
  'getRecognitionBadgeText',

  // Insurance helpers
  'ARGENTINA_INSURANCE_PROVIDERS',

  // Medical record helpers (already documented in glossary)
  'MEDICAL_RECORD_VISIBILITIES', 'isMedicalRecordVisibility', 'canAccessRecord',
  'isHighSensitivityRecord', 'isPermanentRecord'
];

async function validateExports() {
  console.log("üîç Validating exports against glossaries...");

  try {
    // Leer glosarios modulares
    const glossaryDir = "docs/glossary";
    let glosario = "";

    // Si existe el directorio de glosarios, leer todos los archivos .md
    if (fs.existsSync(glossaryDir)) {
      const glossaryFiles = fs.readdirSync(glossaryDir).filter(f => f.endsWith('.md'));
      for (const file of glossaryFiles) {
        const content = fs.readFileSync(path.join(glossaryDir, file), "utf8");
        glosario += content + "\n\n";
      }
      console.log(`üìö Loaded ${glossaryFiles.length} modular glossaries`);
    }

    // Fallback: leer glosario maestro si existe
    const glosarioPath = "docs/GLOSARIO_MAESTRO.md";
    if (fs.existsSync(glosarioPath)) {
      const masterGlosario = fs.readFileSync(glosarioPath, "utf8");
      glosario += masterGlosario;
      console.log("üìö Loaded GLOSARIO_MAESTRO.md");
    }

    if (!glosario) {
      console.warn("‚ö†Ô∏è  No glossaries found, skipping validation");
      return;
    }

    // Extraer exports esperados del glosario
    const expectedExports = extractExpectedExports(glosario);

    // Lista de tipos cr√≠ticos que requieren ADR si cambian
    const CRITICAL_TYPES = [
      'PatientId', 'DoctorId', 'CompanyId', 'UUID',
      'Patient', 'Doctor', 'Appointment', 'MedicalRecord',
      'APIResponse', 'AuthUser', 'UserRole',
      'ISODateString', 'EmailAddress', 'PhoneNumber'
    ];

    // Validar cada package
    const packages = ["types", "shared", "auth", "hooks"];
    let hasErrors = false;
    let hasCriticalChanges = false;

    for (const pkg of packages) {
      const packagePath = `packages/${pkg}/src/index.ts`;

      if (!fs.existsSync(packagePath)) {
        console.error(`‚ùå Package index not found: ${packagePath}`);
        hasErrors = true;
        continue;
      }

      const indexContent = fs.readFileSync(packagePath, "utf8");
      const actualExports = extractActualExports(indexContent);
      const expected = expectedExports[`@autamedica/${pkg}`] || [];

      // Verificar exports faltantes
      const missing = expected.filter(exp => !actualExports.includes(exp));
      if (missing.length > 0) {
        console.error(`‚ùå @autamedica/${pkg} missing exports:`, missing.join(", "));
        hasErrors = true;
      }

      // Verificar exports no documentados (excluyendo internos permitidos)
      const undocumented = actualExports
        .filter(exp => !expected.includes(exp))
        .filter(exp => !ALLOWED_INTERNAL_EXPORTS.includes(exp));

      if (undocumented.length > 0) {
        console.warn(`‚ö†Ô∏è  @autamedica/${pkg} undocumented exports (${undocumented.length}):`, undocumented.join(", "));

        // Verificar si hay tipos cr√≠ticos no documentados
        const criticalUndocumented = undocumented.filter(exp => CRITICAL_TYPES.includes(exp));
        if (criticalUndocumented.length > 0) {
          console.error(`üö® CRITICAL: Undocumented critical types: ${criticalUndocumented.join(", ")}`);
          console.error(`   These require documentation in GLOSARIO_MAESTRO.md and ADR if breaking change`);
          hasErrors = true;
          hasCriticalChanges = true;
        } else {
          // Para exports no cr√≠ticos, marcar para auto-generaci√≥n
          hasErrors = true; // Esto activar√° la auto-generaci√≥n
        }
      }

      // Verificar cambios en tipos cr√≠ticos (para packages types)
      if (pkg === 'types') {
        const criticalExports = actualExports.filter(exp => CRITICAL_TYPES.includes(exp));
        if (criticalExports.length > 0) {
          console.log(`üîí Critical types found: ${criticalExports.join(", ")}`);

          // Si es CI, verificar si hay ADR para cambios cr√≠ticos
          if (process.env.CI && hasCriticalChanges) {
            const adrPath = 'docs/adr';
            if (!fs.existsSync(adrPath)) {
              console.error(`üö® CRITICAL: No ADR directory found at ${adrPath}`);
              console.error(`   Critical type changes require Architecture Decision Records`);
              hasErrors = true;
            } else {
              console.log(`üìã ADR directory exists - ensure critical changes are documented`);
            }
          }
        }
      }

      if (!hasErrors) {
        console.log(`‚úÖ @autamedica/${pkg} exports are valid`);
      }
    }

    if (hasErrors) {
      console.log("\nüîß Intentando generar documentaci√≥n autom√°tica...");

      try {
        await autoGenerateDocs();
        console.log("\n‚ú® Documentaci√≥n generada. Ejecutando validaci√≥n nuevamente...");

        // Re-ejecutar validaci√≥n despu√©s de generar docs
        await validateExportsSecondPass();
      } catch (autoGenError) {
        console.error(`‚ùå Error en auto-generaci√≥n: ${autoGenError.message}`);
        console.error("\n‚ùå Export validation failed!");
        process.exit(1);
      }
    } else {
      console.log("\nüéâ All exports are properly documented and implemented!");
    }

  } catch (error) {
    console.error("‚ùå Validation script failed:", error.message);
    process.exit(1);
  }
}

function normalizeExportName(name) {
  return name
    .trim()
    .replace(/\s+as\s+.+$/iu, "")
    .replace(/\/\*.*?\*\//gu, "")
    .replace(/[\s;]+/g, "")
    .replace(/,$/, "")
    .trim();
}

function collectExportsFromCode(code, exportsSet) {
  // Regex mejorado para capturar export { } multi-l√≠nea
  const namedExportRegex = /export(?:\s+type)?\s*\{([\s\S]*?)\}/g;
  let namedMatch;
  while ((namedMatch = namedExportRegex.exec(code)) !== null) {
    const names = namedMatch[1]
      .split(/[,\n]/)  // Split por comas Y newlines
      .map(normalizeExportName)
      .filter(Boolean);

    for (const name of names) {
      exportsSet.add(name);
    }
  }

  const singleExportRegexes = [
    /export\s+const\s+([A-Za-z0-9_]+)/g,
    /export\s+function\s+([A-Za-z0-9_]+)/g,
    /export\s+class\s+([A-Za-z0-9_]+)/g,
    /export\s+enum\s+([A-Za-z0-9_]+)/g,
    /export\s+interface\s+([A-Za-z0-9_]+)/g,
    /export\s+type\s+([A-Za-z0-9_]+)/g,
  ];

  for (const regex of singleExportRegexes) {
    let singleMatch;
    while ((singleMatch = regex.exec(code)) !== null) {
      const name = normalizeExportName(singleMatch[1]);
      if (name) {
        exportsSet.add(name);
      }
    }
  }
}

function extractExpectedExports(glosarioContent) {
  const expected = {};

  // Priorizar la secci√≥n autogenerada si existe
  const autoSectionMatch = glosarioContent.match(/<!-- AUTOGEN_PACKAGES:START -->([\s\S]*?)<!-- AUTOGEN_PACKAGES:END -->/);
  if (autoSectionMatch) {
    const autoContent = autoSectionMatch[1];
    const lineRegex = /-\s+([a-zA-Z0-9_-]+):\s*([^\n]*)/g;
    let lineMatch;
    while ((lineMatch = lineRegex.exec(autoContent)) !== null) {
      const pkgSlug = lineMatch[1].trim();
      const symbolsLine = lineMatch[2] ?? "";
      const symbols = Array.from(symbolsLine.matchAll(/`([^`]+)`/g))
        .map((match) => match[1].trim())
        .filter(Boolean);
      if (symbols.length > 0) {
        expected[`@autamedica/${pkgSlug}`] = symbols;
      }
    }
  }

  const addCodeBlocksToPackage = (content, packageName) => {
    if (!content) {
      return;
    }

    const exportsSet = new Set(expected[packageName] ?? []);
    const codeBlockRegex = /```typescript([\s\S]*?)```/g;
    let codeMatch;
    while ((codeMatch = codeBlockRegex.exec(content)) !== null) {
      collectExportsFromCode(codeMatch[1], exportsSet);
    }

    if (exportsSet.size > 0) {
      expected[packageName] = [...exportsSet];
    }
  };

  // Bloques generales (antes de la secci√≥n por package) pertenecen a @autamedica/types
  const [generalContent, packagesContent = ""] = glosarioContent.split("## üìñ Exports por Package");
  if (!expected['@autamedica/types']) {
    addCodeBlocksToPackage(generalContent, "@autamedica/types");
  }

  // Capturar el contenido de cada secci√≥n de package del glosario
  // Soporta tanto ### (3 hashes) como ## (2 hashes) para compatibilidad con glosarios modulares
  const sectionRegex = /##+ @autamedica\/([^\n]+)\n([\s\S]*?)(?=##+ @autamedica\/|##+ [A-Z]|$)/g;

  let sectionMatch;
  while ((sectionMatch = sectionRegex.exec(packagesContent)) !== null) {
    const packageName = sectionMatch[1].trim();
    const sectionContent = sectionMatch[2] ?? "";

    if (!expected[`@autamedica/${packageName}`]) {
      addCodeBlocksToPackage(sectionContent, `@autamedica/${packageName}`);
    }
  }

  // Tambi√©n procesar secciones de glosario completo (que incluye modulares)
  // Buscar secciones ## @autamedica/ en todo el contenido
  const fullSectionRegex = /## @autamedica\/([^\n]+)\n([\s\S]*?)(?=## @autamedica\/|## [üéØüìö]|---\n\n##|$)/g;
  let fullMatch;
  while ((fullMatch = fullSectionRegex.exec(glosarioContent)) !== null) {
    const packageName = fullMatch[1].trim();
    const sectionContent = fullMatch[2] ?? "";

    if (!expected[`@autamedica/${packageName}`]) {
      addCodeBlocksToPackage(sectionContent, `@autamedica/${packageName}`);
    }
  }

  return expected;
}

function extractActualExports(indexContent) {
  const exportsSet = new Set();
  collectExportsFromCode(indexContent, exportsSet);
  return [...exportsSet];
}

/**
 * Segunda pasada de validaci√≥n despu√©s de auto-generar documentaci√≥n
 */
async function validateExportsSecondPass() {
  console.log("üîÑ Segunda validaci√≥n despu√©s de auto-generaci√≥n...");

  try {
    // Leer glosarios modulares
    const glossaryDir = "docs/glossary";
    let glosario = "";

    if (fs.existsSync(glossaryDir)) {
      const glossaryFiles = fs.readdirSync(glossaryDir).filter(f => f.endsWith('.md'));
      for (const file of glossaryFiles) {
        const content = fs.readFileSync(path.join(glossaryDir, file), "utf8");
        glosario += content + "\n\n";
      }
    }

    // Fallback: leer glosario maestro
    const glosarioPath = "docs/GLOSARIO_MAESTRO.md";
    if (fs.existsSync(glosarioPath)) {
      const masterGlosario = fs.readFileSync(glosarioPath, "utf8");
      glosario += masterGlosario;
    }

    const expectedExports = extractExpectedExports(glosario);

    // Reutilizar la misma lista ALLOWED_INTERNAL_EXPORTS del m√≥dulo
    const packages = ["types", "shared", "auth", "hooks"];
    let stillHasErrors = false;

    for (const pkg of packages) {
      const packagePath = `packages/${pkg}/src/index.ts`;

      if (!fs.existsSync(packagePath)) {
        continue;
      }

      const indexContent = fs.readFileSync(packagePath, "utf8");
      const actualExports = extractActualExports(indexContent);
      const expected = expectedExports[`@autamedica/${pkg}`] || [];

      // Aplicar MISMO filtro que primera pasada
      const undocumented = actualExports
        .filter(exp => !expected.includes(exp))
        .filter(exp => !ALLOWED_INTERNAL_EXPORTS.includes(exp));

      if (undocumented.length > 0) {
        console.error(`‚ùå @autamedica/${pkg} a√∫n tiene exports sin documentar (${undocumented.length}):`, undocumented.join(", "));
        stillHasErrors = true;
      } else {
        console.log(`‚úÖ @autamedica/${pkg} exports v√°lidos despu√©s de auto-generaci√≥n`);
      }
    }

    if (stillHasErrors) {
      console.error("\n‚ùå Algunos exports siguen sin documentar despu√©s de auto-generaci√≥n!");
      console.error("üîß Revisa el archivo docs/GLOSARIO_MAESTRO.md manualmente");
      process.exit(1);
    } else {
      console.log("\nüéâ ¬°Todos los exports est√°n documentados despu√©s de auto-generaci√≥n!");
    }

  } catch (error) {
    console.error("‚ùå Segunda validaci√≥n fall√≥:", error.message);
    process.exit(1);
  }
}

validateExports();
